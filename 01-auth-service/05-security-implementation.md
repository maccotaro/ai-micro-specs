# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…

**ä½œæˆæ—¥**: 2025-09-30
**æœ€çµ‚æ›´æ–°**: 2025-09-30
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v1.0

## ğŸ“‹ ç›®æ¬¡

- [æ¦‚è¦](#æ¦‚è¦)
- [ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
- [ãƒˆãƒ¼ã‚¯ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#ãƒˆãƒ¼ã‚¯ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
- [é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
- [ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡](#ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡)
- [æ”»æ’ƒå¯¾ç­–](#æ”»æ’ƒå¯¾ç­–)
- [ç›£æŸ»ã¨ãƒ­ã‚®ãƒ³ã‚°](#ç›£æŸ»ã¨ãƒ­ã‚®ãƒ³ã‚°)

---

## æ¦‚è¦

èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹ã¯ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è¦ã¨ãªã‚‹é‡è¦ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã™ã€‚æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å„ç¨®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã«ã¤ã„ã¦è©³è¿°ã—ã¾ã™ã€‚

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆåŸå‰‡

1. **å¤šå±¤é˜²å¾¡ï¼ˆDefense in Depthï¼‰**
   - è¤‡æ•°ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®Ÿè£…
   - ä¸€ã¤ã®å¯¾ç­–ãŒç ´ã‚‰ã‚Œã¦ã‚‚ä»–ã®å¯¾ç­–ã§ã‚«ãƒãƒ¼

2. **æœ€å°æ¨©é™ã®åŸå‰‡ï¼ˆPrinciple of Least Privilegeï¼‰**
   - å¿…è¦æœ€å°é™ã®æ¨©é™ã®ã¿ä»˜ä¸
   - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æ‹’å¦ã€æ˜ç¤ºçš„ã«è¨±å¯

3. **ã‚»ã‚­ãƒ¥ã‚¢ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆSecure by Defaultï¼‰**
   - å®‰å…¨ãªè¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®æ˜ç¤ºçš„ãªç„¡åŠ¹åŒ–ã‚’å¿…é ˆã«

4. **Fail Secure**
   - ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã¯å®‰å…¨å´ã«å€’ã™
   - èªè¨¼å¤±æ•—æ™‚ã¯å¿…ãšã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦

---

## ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–

bcryptã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ã—ã¦ã€ã‚½ãƒ«ãƒˆä»˜ããƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆã—ã¾ã™ã€‚

#### å®Ÿè£…ä¾‹

```python
from passlib.context import CryptContext

# ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š
pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12  # ã‚³ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ï¼ˆå‡¦ç†æ™‚é–“ï¼‰
)

def hash_password(password: str) -> str:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼"""
    return pwd_context.verify(plain_password, hashed_password)
```

#### bcryptç‰¹æ€§

- **ã‚³ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼**: 12ï¼ˆæ¨å¥¨å€¤ï¼‰
  - 2^12å›ã®å†…éƒ¨åå¾©å‡¦ç†
  - ãƒãƒƒã‚·ãƒ¥åŒ–ã«ç´„100-300msã‹ã‹ã‚‹ï¼ˆãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒå¯¾ç­–ï¼‰

- **è‡ªå‹•ã‚½ãƒ«ãƒˆç”Ÿæˆ**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«ç•°ãªã‚‹ã‚½ãƒ«ãƒˆ
- **ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«æ”»æ’ƒå¯¾ç­–**: ã‚½ãƒ«ãƒˆã«ã‚ˆã‚Šç„¡åŠ¹åŒ–

#### ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥ä¾‹

```
å…¥åŠ›: SecurePass123!
å‡ºåŠ›: $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyK.T3lQ.Dz2

æ§‹é€ :
$2b$      â†’ bcryptãƒãƒ¼ã‚¸ãƒ§ãƒ³
12$       â†’ ã‚³ã‚¹ãƒˆãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼
LQv...kCO â†’ ã‚½ãƒ«ãƒˆï¼ˆ22æ–‡å­—ï¼‰
Yz6...Dz2 â†’ ãƒãƒƒã‚·ãƒ¥å€¤ï¼ˆ31æ–‡å­—ï¼‰
```

### ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒªã‚·ãƒ¼

```python
import re
from typing import List

def validate_password_strength(password: str) -> tuple[bool, List[str]]:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦æ¤œè¨¼"""
    errors = []

    # æœ€å°æ–‡å­—æ•°
    if len(password) < 8:
        errors.append("Password must be at least 8 characters")

    # æœ€å¤§æ–‡å­—æ•°
    if len(password) > 128:
        errors.append("Password must be at most 128 characters")

    # å¤§æ–‡å­—ã‚’å«ã‚€
    if not re.search(r'[A-Z]', password):
        errors.append("Password must contain at least one uppercase letter")

    # å°æ–‡å­—ã‚’å«ã‚€
    if not re.search(r'[a-z]', password):
        errors.append("Password must contain at least one lowercase letter")

    # æ•°å­—ã‚’å«ã‚€
    if not re.search(r'\d', password):
        errors.append("Password must contain at least one digit")

    # ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚€ï¼ˆæ¨å¥¨ï¼‰
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        errors.append("Password should contain at least one special character")

    # ä¸€èˆ¬çš„ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    common_passwords = ["password", "12345678", "qwerty"]
    if password.lower() in common_passwords:
        errors.append("Password is too common")

    return len(errors) == 0, errors
```

### ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ

```python
import secrets
from datetime import datetime, timedelta

def generate_reset_token() -> tuple[str, datetime]:
    """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ"""
    # å®‰å…¨ãªãƒ©ãƒ³ãƒ€ãƒ ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼ˆ32ãƒã‚¤ãƒˆ=256ãƒ“ãƒƒãƒˆï¼‰
    token = secrets.token_urlsafe(32)

    # æœ‰åŠ¹æœŸé™: 1æ™‚é–“
    expires_at = datetime.utcnow() + timedelta(hours=1)

    return token, expires_at

async def send_reset_email(email: str, token: str):
    """ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«é€ä¿¡"""
    reset_url = f"https://example.com/reset-password?token={token}"

    # TODO: ãƒ¡ãƒ¼ãƒ«é€ä¿¡å®Ÿè£…
    # - ãƒˆãƒ¼ã‚¯ãƒ³ã‚’Redisã«ä¿å­˜ï¼ˆæœ‰åŠ¹æœŸé™ä»˜ãï¼‰
    # - ãƒ¡ãƒ¼ãƒ«é€ä¿¡ï¼ˆSMTP or ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã‚µãƒ¼ãƒ“ã‚¹ï¼‰
    pass
```

---

## ãƒˆãƒ¼ã‚¯ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### JWTç½²å

RS256ï¼ˆRSA + SHA-256ï¼‰ã«ã‚ˆã‚‹éå¯¾ç§°éµç½²åã‚’å®Ÿè£…ã€‚

```python
from jose import jwt
from datetime import datetime, timedelta
import uuid

# RSAç§˜å¯†éµèª­ã¿è¾¼ã¿
with open("keys/private_key.pem", "r") as f:
    PRIVATE_KEY = f.read()

def create_jwt(
    user_id: str,
    email: str,
    role: str,
    token_type: str = "access",
    expires_delta: timedelta = timedelta(minutes=15)
) -> str:
    """JWTç”Ÿæˆ"""
    now = datetime.utcnow()

    payload = {
        "sub": user_id,
        "email": email,
        "role": role,
        "iss": "https://auth.example.com",
        "aud": "fastapi-api",
        "iat": int(now.timestamp()),
        "exp": int((now + expires_delta).timestamp()),
        "token_type": token_type,
        "jti": str(uuid.uuid4()) if token_type == "refresh" else None
    }

    # Noneå€¤ã‚’é™¤å»
    payload = {k: v for k, v in payload.items() if v is not None}

    return jwt.encode(
        payload,
        PRIVATE_KEY,
        algorithm="RS256",
        headers={"kid": "auth-service-key-1"}
    )
```

### ãƒˆãƒ¼ã‚¯ãƒ³ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆ

Redisã‚’ä½¿ç”¨ã—ã¦ãƒ­ã‚°ã‚¢ã‚¦ãƒˆæ¸ˆã¿ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç®¡ç†ã€‚

```python
import redis.asyncio as redis
from jose import jwt, JWTError

redis_client = redis.from_url("redis://localhost:6379")

async def blacklist_token(token: str):
    """ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆç™»éŒ²"""
    try:
        # ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆæ¤œè¨¼ãªã—ï¼‰
        payload = jwt.get_unverified_claims(token)

        jti = payload.get("jti")
        exp = payload.get("exp")

        if not jti:
            # ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®å ´åˆã€ãƒˆãƒ¼ã‚¯ãƒ³å…¨ä½“ã‚’ã‚­ãƒ¼ã«ã™ã‚‹
            jti = token[:50]  # ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¸€éƒ¨ã‚’ã‚­ãƒ¼ã«

        # æœ‰åŠ¹æœŸé™ã¾ã§ä¿å­˜
        ttl = exp - int(datetime.utcnow().timestamp())
        if ttl > 0:
            await redis_client.setex(
                f"blacklist:{jti}",
                ttl,
                "1"
            )

    except JWTError:
        pass

async def is_token_blacklisted(token: str) -> bool:
    """ãƒˆãƒ¼ã‚¯ãƒ³ãŒãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª"""
    try:
        payload = jwt.get_unverified_claims(token)
        jti = payload.get("jti") or token[:50]

        exists = await redis_client.exists(f"blacklist:{jti}")
        return bool(exists)

    except JWTError:
        return True  # ãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•— = ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³
```

### ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨æ™‚ã«æ–°ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œã—ã€æ—§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç„¡åŠ¹åŒ–ã€‚

```python
async def refresh_access_token(refresh_token: str) -> dict:
    """ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥"""
    # 1. ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
    payload = verify_jwt(refresh_token)

    if payload.get("token_type") != "refresh":
        raise ValueError("Invalid token type")

    # 2. ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆãƒã‚§ãƒƒã‚¯
    if await is_token_blacklisted(refresh_token):
        raise ValueError("Token has been revoked")

    # 3. æ–°ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    new_access_token = create_jwt(
        user_id=payload["sub"],
        email=payload["email"],
        role=payload["role"],
        token_type="access",
        expires_delta=timedelta(minutes=15)
    )

    new_refresh_token = create_jwt(
        user_id=payload["sub"],
        email=payload["email"],
        role=payload["role"],
        token_type="refresh",
        expires_delta=timedelta(days=7)
    )

    # 4. æ—§ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç„¡åŠ¹åŒ–
    await blacklist_token(refresh_token)

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
        "token_type": "Bearer",
        "expires_in": 900
    }
```

---

## é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### HTTPS/TLSè¨­å®š

æœ¬ç•ªç’°å¢ƒã§ã¯å¿…ãšHTTPSã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```python
# Nginxãƒªãƒãƒ¼ã‚¹ãƒ—ãƒ­ã‚­ã‚·è¨­å®šä¾‹
"""
server {
    listen 443 ssl http2;
    server_name auth.example.com;

    ssl_certificate /etc/ssl/certs/cert.pem;
    ssl_certificate_key /etc/ssl/private/key.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    location / {
        proxy_pass http://localhost:8002;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
"""
```

### CORSè¨­å®š

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# CORSè¨­å®š
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3002",  # User Frontend
        "http://localhost:3003",  # Admin Frontend
        "https://app.example.com",  # æœ¬ç•ªç’°å¢ƒ
    ],
    allow_credentials=True,  # Cookieé€ä¿¡ã‚’è¨±å¯
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
    expose_headers=["X-RateLimit-Limit", "X-RateLimit-Remaining"],
)
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼

```python
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)

        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ 
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        response.headers["Referrer-Policy"] = "no-referrer"

        return response

app.add_middleware(SecurityHeadersMiddleware)
```

---

## ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

### ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰

```python
from fastapi import Depends, HTTPException, status
from jose import jwt

def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:
    """ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—"""
    try:
        payload = verify_jwt(token)
        return payload
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

def require_role(required_role: str):
    """ãƒ­ãƒ¼ãƒ«æ¤œè¨¼ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼"""
    def role_checker(current_user: dict = Depends(get_current_user)):
        if current_user.get("role") != required_role:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient permissions"
            )
        return current_user
    return role_checker

# ä½¿ç”¨ä¾‹
@app.get("/admin/users")
async def list_users(current_user: dict = Depends(require_role("admin"))):
    """ç®¡ç†è€…ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½"""
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—å‡¦ç†
    pass
```

### æ¨©é™ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆABACï¼‰

```python
from enum import Enum
from typing import List

class Permission(str, Enum):
    READ_PROFILE = "read:profile"
    WRITE_PROFILE = "write:profile"
    DELETE_USER = "delete:user"
    MANAGE_USERS = "manage:users"

# ãƒ­ãƒ¼ãƒ«ã”ã¨ã®æ¨©é™å®šç¾©
ROLE_PERMISSIONS = {
    "user": [
        Permission.READ_PROFILE,
        Permission.WRITE_PROFILE,
    ],
    "admin": [
        Permission.READ_PROFILE,
        Permission.WRITE_PROFILE,
        Permission.DELETE_USER,
        Permission.MANAGE_USERS,
    ]
}

def require_permission(required_permission: Permission):
    """æ¨©é™æ¤œè¨¼ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼"""
    def permission_checker(current_user: dict = Depends(get_current_user)):
        user_role = current_user.get("role")
        permissions = ROLE_PERMISSIONS.get(user_role, [])

        if required_permission not in permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission '{required_permission}' required"
            )
        return current_user
    return permission_checker
```

---

## æ”»æ’ƒå¯¾ç­–

### ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒå¯¾ç­–

```python
async def handle_failed_login(user_id: str):
    """ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—å‡¦ç†"""
    # å¤±æ•—å›æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    await db.execute(
        """
        UPDATE users
        SET failed_login_attempts = failed_login_attempts + 1,
            locked_until = CASE
                WHEN failed_login_attempts + 1 >= 5
                THEN CURRENT_TIMESTAMP + INTERVAL '15 minutes'
                ELSE locked_until
            END
        WHERE id = $1
        """,
        user_id
    )

async def check_account_lock(user_id: str) -> bool:
    """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ç¢ºèª"""
    result = await db.fetchrow(
        """
        SELECT locked_until, failed_login_attempts
        FROM users
        WHERE id = $1
        """,
        user_id
    )

    if result["locked_until"] and result["locked_until"] > datetime.utcnow():
        return True  # ãƒ­ãƒƒã‚¯ä¸­

    return False

async def reset_failed_attempts(user_id: str):
    """ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã€å¤±æ•—å›æ•°ãƒªã‚»ãƒƒãƒˆ"""
    await db.execute(
        """
        UPDATE users
        SET failed_login_attempts = 0,
            locked_until = NULL,
            last_login_at = CURRENT_TIMESTAMP
        WHERE id = $1
        """,
        user_id
    )
```

### ãƒ¬ãƒ¼ãƒˆåˆ¶é™

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã”ã¨ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™
@app.post("/api/v1/auth/login")
@limiter.limit("5/minute")
async def login(request: Request, credentials: LoginRequest):
    """ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆ5å›/åˆ†ã¾ã§ï¼‰"""
    pass

@app.post("/api/v1/auth/register")
@limiter.limit("3/hour")
async def register(request: Request, user_data: UserCreate):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ï¼ˆ3å›/æ™‚é–“ã¾ã§ï¼‰"""
    pass
```

### SQL ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–

```python
# âœ… æ­£ã—ã„å®Ÿè£…ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªï¼‰
async def get_user_by_email(email: str):
    query = "SELECT * FROM users WHERE email = $1"
    result = await db.fetchrow(query, email)
    return result

# âŒ å±é™ºãªå®Ÿè£…ï¼ˆSQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è„†å¼±æ€§ï¼‰
async def get_user_by_email_unsafe(email: str):
    query = f"SELECT * FROM users WHERE email = '{email}'"
    result = await db.fetchrow(query)
    return result
```

### XSSå¯¾ç­–

```python
from fastapi.responses import JSONResponse
import html

def sanitize_output(data: dict) -> dict:
    """å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚º"""
    if isinstance(data, dict):
        return {k: sanitize_output(v) for k, v in data.items()}
    elif isinstance(data, list):
        return [sanitize_output(item) for item in data]
    elif isinstance(data, str):
        return html.escape(data)
    else:
        return data

# JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯è‡ªå‹•çš„ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã‚‹
@app.get("/api/v1/users/{user_id}")
async def get_user(user_id: str):
    user = await get_user_from_db(user_id)
    # FastAPIãŒè‡ªå‹•çš„ã«å®‰å…¨ãªJSONå¤‰æ›ã‚’è¡Œã†
    return user
```

---

## ç›£æŸ»ã¨ãƒ­ã‚®ãƒ³ã‚°

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ­ã‚®ãƒ³ã‚°

```python
import logging
from datetime import datetime

# ãƒ­ã‚¬ãƒ¼è¨­å®š
security_logger = logging.getLogger("security")
security_logger.setLevel(logging.INFO)

# ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ©
handler = logging.FileHandler("logs/security.log")
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
handler.setFormatter(formatter)
security_logger.addHandler(handler)

def log_security_event(event_type: str, user_id: str, details: dict):
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²"""
    security_logger.info(
        f"Event: {event_type} | User: {user_id} | Details: {details}"
    )

# ä½¿ç”¨ä¾‹
async def login(credentials: LoginRequest):
    user = await authenticate_user(credentials.email, credentials.password)

    if user:
        log_security_event(
            "LOGIN_SUCCESS",
            user.id,
            {"email": credentials.email, "ip": request.client.host}
        )
    else:
        log_security_event(
            "LOGIN_FAILED",
            "unknown",
            {"email": credentials.email, "ip": request.client.host}
        )
```

### ç›£æŸ»è¨¼è·¡

é‡è¦ãªæ“ä½œã‚’è¨˜éŒ²ã™ã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«è¨­è¨ˆï¼š

```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),
    event_type VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100),
    resource_id VARCHAR(255),
    action VARCHAR(50) NOT NULL,
    ip_address INET,
    user_agent TEXT,
    details JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);
```

---

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹æ¦‚è¦](./01-overview.md)
- [JWTè¨­è¨ˆ](./03-jwt-design.md)
- [authdbãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ](./04-database-design.md)
- [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å…¨ä½“æ–¹é‡](../10-security/01-security-overview.md)
- [èªè¨¼ãƒ•ãƒ­ãƒ¼](../08-integration/02-authentication-flow.md)